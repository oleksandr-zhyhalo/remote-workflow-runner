{"version":3,"file":"index.js","mappings":";;;;;;AAAA;;;;;;;;AAAA;;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["../../../../.npm/_npx/7a71fb44c9115061/node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../external node-commonjs \"timers/promises\"","../webpack/bootstrap","../webpack/runtime/compat",".././src/index.js"],"sourcesContent":[null,"module.exports = require(\"timers/promises\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","const core = require('@actions/core');\nconst github = require('@actions/github');\nconst { setTimeout } = require('timers/promises');\n\nasync function run() {\n  try {\n    // Get inputs\n    const targetRepo = core.getInput('target_repo', { required: true });\n    const workflowId = core.getInput('workflow_id', { required: true });\n    const token = core.getInput('github_token', { required: true });\n    const ref = core.getInput('ref');\n    const inputsJson = core.getInput('inputs');\n    const waitInterval = parseInt(core.getInput('wait_interval'), 10);\n    const timeout = parseInt(core.getInput('timeout'), 10);\n    \n    let workflowInputs = {};\n    if (inputsJson) {\n      try {\n        workflowInputs = JSON.parse(inputsJson);\n      } catch (error) {\n        throw new Error(`Failed to parse inputs JSON: ${error.message}`);\n      }\n    }\n    \n    // Create an octokit client\n    const octokit = github.getOctokit(token);\n    const [owner, repo] = targetRepo.split('/');\n    \n    // Trigger the workflow\n    core.info(`Triggering workflow \"${workflowId}\" in repository \"${targetRepo}\" on ref \"${ref}\"`);\n\n    core.info(`API call parameters: \n      owner: ${owner}\n      repo: ${repo}\n      workflow_id: ${workflowId}\n      ref: ${ref}\n      inputs: ${JSON.stringify(workflowInputs)}\n    `);\n    \n    const dispatchResponse = await octokit.rest.actions.createWorkflowDispatch({\n      owner,\n      repo,\n      workflow_id: workflowId,\n      ref,\n      inputs: workflowInputs\n    });\n    \n    if (dispatchResponse.status !== 204) {\n      throw new Error(`Failed to trigger workflow. Status: ${dispatchResponse.status}`);\n    }\n    \n    core.info('Workflow triggered successfully. Waiting for it to start...');\n    \n    // Wait for the workflow to start and get run ID\n    let runId = null;\n    const startTime = Date.now();\n    \n    while (!runId) {\n      if (Date.now() - startTime > timeout * 1000) {\n        throw new Error('Timed out waiting for workflow to start');\n      }\n      \n      // List recent workflow runs\n      const runsResponse = await octokit.rest.actions.listWorkflowRuns({\n        owner,\n        repo,\n        workflow_id: workflowId,\n        branch: ref\n      });\n      \n      // Find the most recent run that was created after we dispatched\n      const run = runsResponse.data.workflow_runs[0];\n      \n      if (run) {\n        runId = run.id;\n        core.info(`Workflow started with run ID: ${runId}`);\n        core.setOutput('run_id', `${runId}`);\n        core.setOutput('workflow_url', run.html_url);\n      } else {\n        core.info('Workflow not yet started. Waiting...');\n        await setTimeout(waitInterval * 1000);\n      }\n    }\n    \n    // Wait for workflow completion\n    let workflowCompleted = false;\n    \n    while (!workflowCompleted) {\n      if (Date.now() - startTime > timeout * 1000) {\n        throw new Error('Timed out waiting for workflow to complete');\n      }\n      \n      const runResponse = await octokit.rest.actions.getWorkflowRun({\n        owner,\n        repo,\n        run_id: runId\n      });\n      \n      const status = runResponse.data.status;\n      const conclusion = runResponse.data.conclusion;\n      \n      core.info(`Workflow status: ${status}, conclusion: ${conclusion || 'N/A'}`);\n      \n      if (status === 'completed') {\n        workflowCompleted = true;\n        core.setOutput('status', status);\n        core.setOutput('conclusion', conclusion);\n        \n        if (conclusion !== 'success') {\n          core.setFailed(`Remote workflow completed with status: ${conclusion}`);\n        } else {\n          core.info('Remote workflow completed successfully!');\n        }\n      } else {\n        core.info(`Waiting for workflow to complete. Current status: ${status}`);\n        await setTimeout(waitInterval * 1000);\n      }\n    }\n    \n  } catch (error) {\n    core.setFailed(`Action failed: ${error.message}`);\n  }\n}\n\nrun();\n"],"names":[],"sourceRoot":""}